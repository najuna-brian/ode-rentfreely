/**
 * FormulusInterfaceDefinition.ts
 *
 * This module defines the shared interface between the Formulus React Native app and the Formplayer WebView.
 * It serves as the single source of truth for the interface definition.
 *
 * NOTE: This file should be manually copied to client projects that need to interact with the Formulus app.
 * If you've checked out the monorepo use:
 * cp ..\formulus\src\webview\FormulusInterfaceDefinition.ts .\src\FormulusInterfaceDefinition.ts
 *
 * Current Version: 1.0.17
 */

/**
 * Extension metadata for custom app extensions
 */
export interface ExtensionMetadata {
  definitions?: Record<string, any>;
  functions?: Record<
    string,
    {
      name: string;
      module: string;
      export?: string;
    }
  >;
  renderers?: Record<
    string,
    {
      name: string;
      format: string;
      module: string;
      tester?: string;
      renderer?: string;
    }
  >;
  basePath?: string; // Base path for loading modules
}

/**
 * Data passed to the Formulus app when a form is initialized
 * @property {string} formType - The form type (e.g. 'form1')
 * @property {string | null} observationId - The observation ID (generated by the database on first form submission). NULL if this is a new form.
 * @property {Record<string, any>} params - Additional parameters for form initialization
 * @property {Record<string, any>} savedData - Previously saved form data (for editing)
 * @property {any} [formSchema] - JSON Schema for the form structure and validation (optional)
 * @property {any} [uiSchema] - UI Schema for form rendering layout (optional)
 * @property {ExtensionMetadata} [extensions] - Custom app extensions (optional)
 */
export interface FormInitData {
  formType: string;
  observationId: string | null;
  params: Record<string, any>;
  savedData: Record<string, any>;
  formSchema?: any;
  uiSchema?: any;
  extensions?: ExtensionMetadata;
}

/**
 * Generic result type for media/action requests (camera, audio, signature, etc.)
 * @property {string} fieldId - The ID of the field that triggered the action
 * @property {'success' | 'cancelled' | 'error'} status - The outcome status
 * @property {string} [message] - Optional message (mainly for errors)
 * @property {T} [data] - Action-specific result data (only present on success)
 */
export interface ActionResult<T = any> {
  fieldId: string;
  status: 'success' | 'cancelled' | 'error';
  message?: string;
  data?: T;
}

/**
 * Camera-specific result data
 * @property {'image'} type - Always 'image' for camera results
 * @property {string} filename - Generated filename for the image
 * @property {string} timestamp - ISO timestamp when image was captured
 * @property {object} metadata - Image metadata (dimensions, size, etc.)
 */
export interface CameraResultData {
  type: 'image';
  id: string;
  filename: string;
  uri: string;
  url: string;
  timestamp: string;
  metadata: {
    width: number;
    height: number;
    size: number;
    mimeType: string;
    source: string;
    quality: number;
    originalFileName?: string;
    persistentStorage: boolean;
    storageLocation: string;
  };
}

/**
 * Audio-specific result data
 * @property {'audio'} type - Always 'audio' for audio results
 * @property {string} filename - Generated filename for the audio
 * @property {string} base64 - Base64 encoded audio data
 * @property {string} url - Data URL for the audio
 * @property {string} timestamp - ISO timestamp when audio was recorded
 * @property {object} metadata - Audio metadata (duration, format, etc.)
 */
export interface AudioResultData {
  type: 'audio';
  filename: string;
  base64: string;
  url: string;
  timestamp: string;
  metadata: {
    duration: number;
    format: string;
    sampleRate: number;
    channels: number;
    size: number;
  };
}

/**
 * Signature-specific result data
 * @property {'signature'} type - Always 'signature' for signature results
 * @property {string} filename - Generated filename for the signature
 * @property {string} uri - File URI for the signature image
 * @property {string} timestamp - ISO timestamp when signature was captured
 * @property {object} metadata - Signature metadata (dimensions, etc.)
 */
export interface SignatureResultData {
  type: 'signature';
  filename: string;
  uri: string;
  timestamp: string;
  metadata: {
    width: number;
    height: number;
    size: number;
    strokeCount: number;
  };
}

/**
 * QR code-specific result data
 * @property {'qrcode'} type - Always 'qrcode' for QR code results
 * @property {string} value - The decoded QR code string value
 * @property {string} timestamp - ISO timestamp when QR code was scanned
 */
export interface QrcodeResultData {
  type: 'qrcode';
  value: string;
  timestamp: string;
}

/**
 * File selection result data
 * @property {'file'} type - Always 'file' for file selection results
 * @property {string} filename - Original filename of the selected file
 * @property {string} uri - Local file URI (no base64 encoding)
 * @property {string} mimeType - MIME type of the selected file
 * @property {number} size - File size in bytes
 * @property {string} timestamp - ISO timestamp when file was selected
 * @property {object} metadata - File metadata (extension, original path, etc.)
 */
export interface FileResultData {
  type: 'file';
  filename: string;
  uri: string; // Local file URI (no base64 encoding)
  mimeType: string;
  size: number;
  timestamp: string;
  metadata: {
    extension: string;
    originalPath?: string;
  };
}

/**
 * Type aliases for specific action results
 */
export type CameraResult = ActionResult<CameraResultData>;
export type AudioResult = ActionResult<AudioResultData>;
export type SignatureResult = ActionResult<SignatureResultData>;
export type QrcodeResult = ActionResult<QrcodeResultData>;
export type FileResult = ActionResult<FileResultData>;

/**
 * @deprecated Use ActionResult<CameraResultData> instead
 * Data passed to the Formulus app when an attachment is ready
 * @property {string} fieldId - The ID of the field
 * @property {string} type - The type of the attachment
 * @property {any} [key: string] - Additional properties based on type
 */
export interface AttachmentData {
  fieldId: string;
  type:
    | 'image'
    | 'location'
    | 'file'
    | 'intent'
    | 'subform'
    | 'audio'
    | 'signature'
    | 'biometric'
    | 'connectivity'
    | 'sync'
    | 'ml_result';
  [key: string]: any;
}

/**
 * Information about a form
 * @property {string} formType - The form type (e.g. 'form1')
 * @property {string} name - The name of the form
 * @property {string} version - The version of the form
 * @property {string[]} coreFields - The core fields of the form
 * @property {string[]} auxiliaryFields - The auxiliary fields of the form
 */
export interface FormInfo {
  formType: string;
  name: string;
  version: string;
  coreFields: string[];
  auxiliaryFields: string[];
}

/**
 * Information about a form observation
 * @property {string} observationId - The observation ID (generated by the database on first form submission)
 * @property {Date} createdAt - The date the observation was created
 * @property {Date} updatedAt - The date the observation was last updated
 * @property {Date} syncedAt - The date the observation was synced
 * @property {boolean} isDraft - Whether the observation is a draft
 * @property {boolean} deleted - Whether the observation has been deleted
 * @property {string} formType - The form type (e.g. 'form1')
 * @property {string} formVersion - The version of the form
 * @property {Record<string, any>} data - The form data
 */
export interface FormObservation {
  observationId: string;
  createdAt: Date;
  updatedAt: Date;
  syncedAt: Date;
  isDraft: boolean;
  deleted: boolean;
  formType: string;
  formVersion: string;
  data: Record<string, any>;
}

/**
 * Result returned when a form is completed or closed
 * @property {'form_submitted' | 'form_updated' | 'draft_saved' | 'cancelled' | 'error'} status - The outcome status
 * @property {string} [observationId] - The observation ID (present on successful submission/update)
 * @property {Record<string, any>} [formData] - The final form data (present on successful submission/update)
 * @property {string} [message] - Optional message (mainly for errors or additional context)
 * @property {string} formType - The form type that was being edited
 */
export interface FormCompletionResult {
  status: 'form_submitted' | 'form_updated' | 'draft_saved' | 'cancelled' | 'error';
  observationId?: string;
  formData?: Record<string, any>;
  message?: string;
  formType: string;
}

/**
 * Interface for the Formulus app methods that will be injected into the WebViews for custom_app and FormPlayer
 * @namespace formulus
 */
export interface FormulusInterface {
  /**
   * Get the current version of the Formulus API
   * @returns {Promise<string>} The API version
   */
  getVersion(): Promise<string>;

  /**
   * Get a list of available forms
   * @returns {Promise<FormInfo[]>} Array of form information objects
   */
  getAvailableForms(): Promise<FormInfo[]>;

  /**
   * Open Formplayer with the specified form
   * @param {string} formType - The identifier of the formtype to open
   * @param {Object} params - Additional parameters for form initialization
   * @param {Object} savedData - Previously saved form data (for editing)
   * @returns {Promise<FormCompletionResult>} Promise that resolves when the form is completed/closed with result details
   */
  openFormplayer(
    formType: string,
    params: Record<string, any>,
    savedData: Record<string, any>,
  ): Promise<FormCompletionResult>;

  /**
   * Get observations for a specific form
   * @param {string} formType - The identifier of the formtype
   * @param {boolean} [isDraft=false] - Whether to include draft observations
   * @param {boolean} [includeDeleted=false] - Whether to include deleted observations
   * @returns {Promise<FormObservation[]>} Array of form observations
   */
  getObservations(
    formType: string,
    isDraft?: boolean,
    includeDeleted?: boolean,
  ): Promise<FormObservation[]>;

  /**
   * Submit a completed form
   * @param {string} formType - The identifier of the formtype
   * @param {Object} finalData - The final form data to submit
   * @returns {Promise<string>} The observationId of the submitted form
   */
  submitObservation(formType: string, finalData: Record<string, any>): Promise<string>;

  /**
   * Update an existing form
   * @param {string} observationId - The identifier of the observation
   * @param {string} formType - The identifier of the formtype
   * @param {Object} finalData - The final form data to update
   * @returns {Promise<string>} The observationId of the updated form
   */
  updateObservation(
    observationId: string,
    formType: string,
    finalData: Record<string, any>,
  ): Promise<string>;

  /**
   * Request camera access for a field
   * @param {string} fieldId - The ID of the field
   * @returns {Promise<CameraResult>} Promise that resolves with camera result or rejects on error/cancellation
   */
  requestCamera(fieldId: string): Promise<CameraResult>;

  /**
   * Request location for a field
   * @param {string} fieldId - The ID of the field
   * @returns {Promise<void>}
   */
  requestLocation(fieldId: string): Promise<void>;

  /**
   * Request file selection for a field
   * @param {string} fieldId - The ID of the field
   * @returns {Promise<FileResult>} Promise that resolves with file result or rejects on error/cancellation
   */
  requestFile(fieldId: string): Promise<FileResult>;

  /**
   * Launch an external intent
   * @param {string} fieldId - The ID of the field
   * @param {Object} intentSpec - The intent specification
   * @returns {Promise<void>}
   */
  launchIntent(fieldId: string, intentSpec: Record<string, any>): Promise<void>;

  /**
   * Call a subform
   * @param {string} fieldId - The ID of the field
   * @param {string} formType - The ID of the subform
   * @param {Object} options - Additional options for the subform
   * @returns {Promise<void>}
   */
  callSubform(fieldId: string, formType: string, options: Record<string, any>): Promise<void>;

  /**
   * Request audio recording for a field
   * @param {string} fieldId - The ID of the field
   * @returns {Promise<AudioResult>} Promise that resolves with audio result or rejects on error/cancellation
   */
  requestAudio(fieldId: string): Promise<AudioResult>;

  /**
   * Request signature for a field
   * @param {string} fieldId - The ID of the field
   * @returns {Promise<SignatureResult>} Promise that resolves with signature result or rejects on error/cancellation
   */
  requestSignature(fieldId: string): Promise<SignatureResult>;

  /**
   * Request QR code scanning for a field
   * @param {string} fieldId - The ID of the field
   * @returns {Promise<QrcodeResult>} Promise that resolves with QR code result or rejects on error/cancellation
   */
  requestQrcode(fieldId: string): Promise<QrcodeResult>;

  /**
   * Request biometric authentication
   * @param {string} fieldId - The ID of the field
   * @returns {Promise<void>}
   */
  requestBiometric(fieldId: string): Promise<void>;

  /**
   * Request the current connectivity status
   * @returns {Promise<void>}
   */
  requestConnectivityStatus(): Promise<void>;

  /**
   * Request the current sync status
   * @returns {Promise<void>}
   */
  requestSyncStatus(): Promise<void>;

  /**
   * Run a local ML model
   * @param {string} fieldId - The ID of the field
   * @param {string} modelId - The ID of the model to run
   * @param {Object} input - The input data for the model
   * @returns {Promise<void>}
   */
  runLocalModel(fieldId: string, modelId: string, input: Record<string, any>): Promise<void>;
}

/**
 * Interface for callback methods that the Formplayer WebView implements
 */
export interface FormulusCallbacks {
  onFormInit?: (
    formType: string,
    observationId: string | null,
    params: Record<string, any>,
    savedData: Record<string, any>,
  ) => void;
  onReceiveFocus?: () => void;
}

/**
 * Current version of the interface
 */
export const FORMULUS_INTERFACE_VERSION = '1.1.0';

/**
 * Check if the current interface version is compatible with the required version
 */
export function isCompatibleVersion(requiredVersion: string): boolean {
  // Simple version comparison - can be enhanced for semantic versioning
  return FORMULUS_INTERFACE_VERSION >= requiredVersion;
}

// Extend the global interface to include the Formulus interface
declare global {
  var formulus: FormulusInterface | undefined;
  var onFormInit: FormulusCallbacks['onFormInit'];
  var onReceiveFocus: FormulusCallbacks['onReceiveFocus'];
}
