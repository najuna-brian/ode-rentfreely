/* tslint:disable */
/* eslint-disable */
/**
 * Synkronus API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.3
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type {Configuration} from './configuration';
import type {AxiosPromise, AxiosInstance, RawAxiosRequestConfig} from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
import type {RequestArgs} from './base';
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from './base';

/**
 *
 * @export
 * @interface AppBundleChangeLog
 */
export interface AppBundleChangeLog {
  /**
   *
   * @type {string}
   * @memberof AppBundleChangeLog
   */
  compare_version_a: string;
  /**
   *
   * @type {string}
   * @memberof AppBundleChangeLog
   */
  compare_version_b: string;
  /**
   *
   * @type {boolean}
   * @memberof AppBundleChangeLog
   */
  form_changes: boolean;
  /**
   *
   * @type {boolean}
   * @memberof AppBundleChangeLog
   */
  ui_changes: boolean;
  /**
   *
   * @type {Array<FormDiff>}
   * @memberof AppBundleChangeLog
   */
  new_forms?: Array<FormDiff>;
  /**
   *
   * @type {Array<FormDiff>}
   * @memberof AppBundleChangeLog
   */
  removed_forms?: Array<FormDiff>;
  /**
   *
   * @type {Array<FormModification>}
   * @memberof AppBundleChangeLog
   */
  modified_forms?: Array<FormModification>;
}
/**
 *
 * @export
 * @interface AppBundleFile
 */
export interface AppBundleFile {
  /**
   *
   * @type {string}
   * @memberof AppBundleFile
   */
  path: string;
  /**
   *
   * @type {number}
   * @memberof AppBundleFile
   */
  size: number;
  /**
   *
   * @type {string}
   * @memberof AppBundleFile
   */
  hash: string;
  /**
   *
   * @type {string}
   * @memberof AppBundleFile
   */
  mimeType: string;
  /**
   *
   * @type {string}
   * @memberof AppBundleFile
   */
  modTime: string;
}
/**
 *
 * @export
 * @interface AppBundleManifest
 */
export interface AppBundleManifest {
  /**
   *
   * @type {Array<AppBundleFile>}
   * @memberof AppBundleManifest
   */
  files: Array<AppBundleFile>;
  /**
   *
   * @type {string}
   * @memberof AppBundleManifest
   */
  version: string;
  /**
   *
   * @type {string}
   * @memberof AppBundleManifest
   */
  generatedAt: string;
  /**
   *
   * @type {string}
   * @memberof AppBundleManifest
   */
  hash: string;
}
/**
 *
 * @export
 * @interface AppBundlePushResponse
 */
export interface AppBundlePushResponse {
  /**
   *
   * @type {string}
   * @memberof AppBundlePushResponse
   */
  message: string;
  /**
   *
   * @type {AppBundleManifest}
   * @memberof AppBundlePushResponse
   */
  manifest: AppBundleManifest;
}
/**
 *
 * @export
 * @interface AppBundleVersions
 */
export interface AppBundleVersions {
  /**
   *
   * @type {Array<string>}
   * @memberof AppBundleVersions
   */
  versions: Array<string>;
}
/**
 *
 * @export
 * @interface AttachmentManifestRequest
 */
export interface AttachmentManifestRequest {
  /**
   * Unique identifier for the client requesting the manifest
   * @type {string}
   * @memberof AttachmentManifestRequest
   */
  client_id: string;
  /**
   * Data version number from which to get attachment changes (0 for all attachments)
   * @type {number}
   * @memberof AttachmentManifestRequest
   */
  since_version: number;
}
/**
 *
 * @export
 * @interface AttachmentManifestResponse
 */
export interface AttachmentManifestResponse {
  /**
   * Current database version number
   * @type {number}
   * @memberof AttachmentManifestResponse
   */
  current_version: number;
  /**
   * List of attachment operations to perform
   * @type {Array<AttachmentOperation>}
   * @memberof AttachmentManifestResponse
   */
  operations: Array<AttachmentOperation>;
  /**
   * Total size in bytes of all attachments to download
   * @type {number}
   * @memberof AttachmentManifestResponse
   */
  total_download_size?: number;
  /**
   *
   * @type {AttachmentManifestResponseOperationCount}
   * @memberof AttachmentManifestResponse
   */
  operation_count?: AttachmentManifestResponseOperationCount;
}
/**
 * Count of operations by type
 * @export
 * @interface AttachmentManifestResponseOperationCount
 */
export interface AttachmentManifestResponseOperationCount {
  /**
   *
   * @type {number}
   * @memberof AttachmentManifestResponseOperationCount
   */
  download?: number;
  /**
   *
   * @type {number}
   * @memberof AttachmentManifestResponseOperationCount
   */
  delete?: number;
}
/**
 *
 * @export
 * @interface AttachmentOperation
 */
export interface AttachmentOperation {
  /**
   * Operation to perform on the attachment
   * @type {string}
   * @memberof AttachmentOperation
   */
  operation: AttachmentOperationOperationEnum;
  /**
   * Unique identifier for the attachment
   * @type {string}
   * @memberof AttachmentOperation
   */
  attachment_id: string;
  /**
   * URL to download the attachment (only present for download operations)
   * @type {string}
   * @memberof AttachmentOperation
   */
  download_url?: string;
  /**
   * Size of the attachment in bytes (only present for download operations)
   * @type {number}
   * @memberof AttachmentOperation
   */
  size?: number;
  /**
   * MIME type of the attachment (only present for download operations)
   * @type {string}
   * @memberof AttachmentOperation
   */
  content_type?: string;
  /**
   * Version when this attachment was created/modified/deleted
   * @type {number}
   * @memberof AttachmentOperation
   */
  version?: number;
}

export const AttachmentOperationOperationEnum = {
  Download: 'download',
  Delete: 'delete',
} as const;

export type AttachmentOperationOperationEnum =
  (typeof AttachmentOperationOperationEnum)[keyof typeof AttachmentOperationOperationEnum];

/**
 *
 * @export
 * @interface AuthResponse
 */
export interface AuthResponse {
  /**
   *
   * @type {string}
   * @memberof AuthResponse
   */
  token: string;
  /**
   *
   * @type {string}
   * @memberof AuthResponse
   */
  refreshToken: string;
  /**
   *
   * @type {number}
   * @memberof AuthResponse
   */
  expiresAt: number;
}
/**
 *
 * @export
 * @interface BuildInfo
 */
export interface BuildInfo {
  /**
   *
   * @type {string}
   * @memberof BuildInfo
   */
  commit?: string;
  /**
   *
   * @type {string}
   * @memberof BuildInfo
   */
  build_time?: string;
  /**
   *
   * @type {string}
   * @memberof BuildInfo
   */
  go_version?: string;
}
/**
 *
 * @export
 * @interface ChangeLog
 */
export interface ChangeLog {
  /**
   *
   * @type {string}
   * @memberof ChangeLog
   */
  compare_version_a?: string;
  /**
   *
   * @type {string}
   * @memberof ChangeLog
   */
  compare_version_b?: string;
  /**
   *
   * @type {boolean}
   * @memberof ChangeLog
   */
  form_changes?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ChangeLog
   */
  ui_changes?: boolean;
  /**
   *
   * @type {Array<FormDiff>}
   * @memberof ChangeLog
   */
  new_forms?: Array<FormDiff>;
  /**
   *
   * @type {Array<FormDiff>}
   * @memberof ChangeLog
   */
  removed_forms?: Array<FormDiff>;
  /**
   *
   * @type {Array<FormModification>}
   * @memberof ChangeLog
   */
  modified_forms?: Array<FormModification>;
}
/**
 *
 * @export
 * @interface ChangePassword200Response
 */
export interface ChangePassword200Response {
  /**
   *
   * @type {string}
   * @memberof ChangePassword200Response
   */
  message?: string;
}
/**
 *
 * @export
 * @interface ChangePasswordRequest
 */
export interface ChangePasswordRequest {
  /**
   * Current password for verification
   * @type {string}
   * @memberof ChangePasswordRequest
   */
  currentPassword: string;
  /**
   * New password to set
   * @type {string}
   * @memberof ChangePasswordRequest
   */
  newPassword: string;
}
/**
 *
 * @export
 * @interface CreateUserRequest
 */
export interface CreateUserRequest {
  /**
   * New user\'s username
   * @type {string}
   * @memberof CreateUserRequest
   */
  username: string;
  /**
   * New user\'s password
   * @type {string}
   * @memberof CreateUserRequest
   */
  password: string;
  /**
   * User\'s role
   * @type {string}
   * @memberof CreateUserRequest
   */
  role: CreateUserRequestRoleEnum;
}

export const CreateUserRequestRoleEnum = {
  ReadOnly: 'read-only',
  ReadWrite: 'read-write',
  Admin: 'admin',
} as const;

export type CreateUserRequestRoleEnum =
  (typeof CreateUserRequestRoleEnum)[keyof typeof CreateUserRequestRoleEnum];

/**
 *
 * @export
 * @interface DatabaseInfo
 */
export interface DatabaseInfo {
  /**
   *
   * @type {string}
   * @memberof DatabaseInfo
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof DatabaseInfo
   */
  version?: string;
  /**
   *
   * @type {string}
   * @memberof DatabaseInfo
   */
  database_name?: string;
}
/**
 *
 * @export
 * @interface DeleteUser200Response
 */
export interface DeleteUser200Response {
  /**
   *
   * @type {string}
   * @memberof DeleteUser200Response
   */
  message?: string;
}
/**
 *
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
  /**
   *
   * @type {string}
   * @memberof ErrorResponse
   */
  error?: string;
}
/**
 *
 * @export
 * @interface FieldChange
 */
export interface FieldChange {
  /**
   *
   * @type {string}
   * @memberof FieldChange
   */
  field?: string;
  /**
   *
   * @type {string}
   * @memberof FieldChange
   */
  type?: string;
}
/**
 *
 * @export
 * @interface FormDiff
 */
export interface FormDiff {
  /**
   *
   * @type {string}
   * @memberof FormDiff
   */
  form?: string;
}
/**
 *
 * @export
 * @interface FormModification
 */
export interface FormModification {
  /**
   *
   * @type {string}
   * @memberof FormModification
   */
  form?: string;
  /**
   *
   * @type {boolean}
   * @memberof FormModification
   */
  schema_changed?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof FormModification
   */
  ui_changed?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof FormModification
   */
  core_changed?: boolean;
  /**
   *
   * @type {Array<FieldChange>}
   * @memberof FormModification
   */
  added_fields?: Array<FieldChange>;
  /**
   *
   * @type {Array<FieldChange>}
   * @memberof FormModification
   */
  removed_fields?: Array<FieldChange>;
}
/**
 *
 * @export
 * @interface GetHealth200Response
 */
export interface GetHealth200Response {
  /**
   *
   * @type {string}
   * @memberof GetHealth200Response
   */
  status?: GetHealth200ResponseStatusEnum;
  /**
   * Current server time
   * @type {string}
   * @memberof GetHealth200Response
   */
  timestamp?: string;
  /**
   * Current API version
   * @type {string}
   * @memberof GetHealth200Response
   */
  version?: string;
}

export const GetHealth200ResponseStatusEnum = {
  Ok: 'ok',
} as const;

export type GetHealth200ResponseStatusEnum =
  (typeof GetHealth200ResponseStatusEnum)[keyof typeof GetHealth200ResponseStatusEnum];

/**
 *
 * @export
 * @interface GetHealth503Response
 */
export interface GetHealth503Response {
  /**
   *
   * @type {string}
   * @memberof GetHealth503Response
   */
  status?: GetHealth503ResponseStatusEnum;
  /**
   * Description of the error
   * @type {string}
   * @memberof GetHealth503Response
   */
  error?: string;
  /**
   * Current server time
   * @type {string}
   * @memberof GetHealth503Response
   */
  timestamp?: string;
}

export const GetHealth503ResponseStatusEnum = {
  Error: 'error',
} as const;

export type GetHealth503ResponseStatusEnum =
  (typeof GetHealth503ResponseStatusEnum)[keyof typeof GetHealth503ResponseStatusEnum];

/**
 *
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
  /**
   * User\'s username
   * @type {string}
   * @memberof LoginRequest
   */
  username: string;
  /**
   * User\'s password
   * @type {string}
   * @memberof LoginRequest
   */
  password: string;
}
/**
 *
 * @export
 * @interface Observation
 */
export interface Observation {
  /**
   *
   * @type {string}
   * @memberof Observation
   */
  observation_id: string;
  /**
   *
   * @type {string}
   * @memberof Observation
   */
  form_type: string;
  /**
   *
   * @type {string}
   * @memberof Observation
   */
  form_version: string;
  /**
   * Arbitrary JSON object containing form data
   * @type {object}
   * @memberof Observation
   */
  data: object;
  /**
   *
   * @type {string}
   * @memberof Observation
   */
  created_at: string;
  /**
   *
   * @type {string}
   * @memberof Observation
   */
  updated_at: string;
  /**
   *
   * @type {string}
   * @memberof Observation
   */
  synced_at?: string | null;
  /**
   *
   * @type {boolean}
   * @memberof Observation
   */
  deleted: boolean;
  /**
   *
   * @type {ObservationGeolocation}
   * @memberof Observation
   */
  geolocation?: ObservationGeolocation | null;
  /**
   * Author/creator of the observation
   * @type {string}
   * @memberof Observation
   */
  author: string;
  /**
   * Device ID that created the observation
   * @type {string}
   * @memberof Observation
   */
  device_id: string;
}
/**
 * Optional geolocation data for the observation
 * @export
 * @interface ObservationGeolocation
 */
export interface ObservationGeolocation {
  /**
   * Latitude in decimal degrees
   * @type {number}
   * @memberof ObservationGeolocation
   */
  latitude?: number;
  /**
   * Longitude in decimal degrees
   * @type {number}
   * @memberof ObservationGeolocation
   */
  longitude?: number;
  /**
   * Horizontal accuracy in meters
   * @type {number}
   * @memberof ObservationGeolocation
   */
  accuracy?: number;
  /**
   * Elevation in meters above sea level
   * @type {number}
   * @memberof ObservationGeolocation
   */
  altitude?: number | null;
  /**
   * Vertical accuracy in meters
   * @type {number}
   * @memberof ObservationGeolocation
   */
  altitude_accuracy?: number | null;
}
/**
 *
 * @export
 * @interface ProblemDetail
 */
export interface ProblemDetail {
  /**
   *
   * @type {string}
   * @memberof ProblemDetail
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof ProblemDetail
   */
  title: string;
  /**
   *
   * @type {number}
   * @memberof ProblemDetail
   */
  status: number;
  /**
   *
   * @type {string}
   * @memberof ProblemDetail
   */
  detail: string;
  /**
   *
   * @type {string}
   * @memberof ProblemDetail
   */
  instance?: string;
  /**
   *
   * @type {Array<ProblemDetailErrorsInner>}
   * @memberof ProblemDetail
   */
  errors?: Array<ProblemDetailErrorsInner>;
}
/**
 *
 * @export
 * @interface ProblemDetailErrorsInner
 */
export interface ProblemDetailErrorsInner {
  /**
   *
   * @type {string}
   * @memberof ProblemDetailErrorsInner
   */
  field?: string;
  /**
   *
   * @type {string}
   * @memberof ProblemDetailErrorsInner
   */
  message?: string;
}
/**
 *
 * @export
 * @interface RefreshTokenRequest
 */
export interface RefreshTokenRequest {
  /**
   * Refresh token obtained from login or previous refresh
   * @type {string}
   * @memberof RefreshTokenRequest
   */
  refreshToken: string;
}
/**
 *
 * @export
 * @interface ResetUserPassword200Response
 */
export interface ResetUserPassword200Response {
  /**
   *
   * @type {string}
   * @memberof ResetUserPassword200Response
   */
  message?: string;
}
/**
 *
 * @export
 * @interface ResetUserPasswordRequest
 */
export interface ResetUserPasswordRequest {
  /**
   * Username of the user whose password is being reset
   * @type {string}
   * @memberof ResetUserPasswordRequest
   */
  username: string;
  /**
   * New password for the user
   * @type {string}
   * @memberof ResetUserPasswordRequest
   */
  newPassword: string;
}
/**
 *
 * @export
 * @interface ServerInfo
 */
export interface ServerInfo {
  /**
   *
   * @type {string}
   * @memberof ServerInfo
   */
  version?: string;
}
/**
 *
 * @export
 * @interface SwitchAppBundleVersion200Response
 */
export interface SwitchAppBundleVersion200Response {
  /**
   *
   * @type {string}
   * @memberof SwitchAppBundleVersion200Response
   */
  message?: string;
}
/**
 *
 * @export
 * @interface SyncPullRequest
 */
export interface SyncPullRequest {
  /**
   *
   * @type {string}
   * @memberof SyncPullRequest
   */
  client_id: string;
  /**
   *
   * @type {SyncPullRequestSince}
   * @memberof SyncPullRequest
   */
  since?: SyncPullRequestSince;
  /**
   *
   * @type {Array<string>}
   * @memberof SyncPullRequest
   */
  schema_types?: Array<string>;
}
/**
 * Optional pagination cursor indicating the last seen change
 * @export
 * @interface SyncPullRequestSince
 */
export interface SyncPullRequestSince {
  /**
   *
   * @type {number}
   * @memberof SyncPullRequestSince
   */
  version?: number;
  /**
   *
   * @type {string}
   * @memberof SyncPullRequestSince
   */
  id?: string;
}
/**
 *
 * @export
 * @interface SyncPullResponse
 */
export interface SyncPullResponse {
  /**
   * Current database version number that increments with each update
   * @type {number}
   * @memberof SyncPullResponse
   */
  current_version: number;
  /**
   *
   * @type {Array<Observation>}
   * @memberof SyncPullResponse
   */
  records: Array<Observation>;
  /**
   * Version number of the last change included in this response. Use this as the next \'since.version\' for pagination.
   * @type {number}
   * @memberof SyncPullResponse
   */
  change_cutoff: number;
  /**
   * Indicates if there are more records available beyond this response
   * @type {boolean}
   * @memberof SyncPullResponse
   */
  has_more?: boolean;
  /**
   *
   * @type {string}
   * @memberof SyncPullResponse
   */
  sync_format_version?: string;
}
/**
 *
 * @export
 * @interface SyncPushRequest
 */
export interface SyncPushRequest {
  /**
   *
   * @type {string}
   * @memberof SyncPushRequest
   */
  transmission_id: string;
  /**
   *
   * @type {string}
   * @memberof SyncPushRequest
   */
  client_id: string;
  /**
   *
   * @type {Array<Observation>}
   * @memberof SyncPushRequest
   */
  records: Array<Observation>;
}
/**
 *
 * @export
 * @interface SyncPushResponse
 */
export interface SyncPushResponse {
  /**
   * Current database version number after processing the push
   * @type {number}
   * @memberof SyncPushResponse
   */
  current_version: number;
  /**
   *
   * @type {number}
   * @memberof SyncPushResponse
   */
  success_count: number;
  /**
   *
   * @type {Array<object>}
   * @memberof SyncPushResponse
   */
  failed_records?: Array<object>;
  /**
   *
   * @type {Array<SyncPushResponseWarningsInner>}
   * @memberof SyncPushResponse
   */
  warnings?: Array<SyncPushResponseWarningsInner>;
}
/**
 *
 * @export
 * @interface SyncPushResponseWarningsInner
 */
export interface SyncPushResponseWarningsInner {
  /**
   *
   * @type {string}
   * @memberof SyncPushResponseWarningsInner
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof SyncPushResponseWarningsInner
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof SyncPushResponseWarningsInner
   */
  message: string;
}
/**
 *
 * @export
 * @interface SystemInfo
 */
export interface SystemInfo {
  /**
   *
   * @type {string}
   * @memberof SystemInfo
   */
  os?: string;
  /**
   *
   * @type {string}
   * @memberof SystemInfo
   */
  architecture?: string;
  /**
   *
   * @type {number}
   * @memberof SystemInfo
   */
  cpus?: number;
}
/**
 *
 * @export
 * @interface SystemVersionInfo
 */
export interface SystemVersionInfo {
  /**
   *
   * @type {ServerInfo}
   * @memberof SystemVersionInfo
   */
  server?: ServerInfo;
  /**
   *
   * @type {DatabaseInfo}
   * @memberof SystemVersionInfo
   */
  database?: DatabaseInfo;
  /**
   *
   * @type {SystemInfo}
   * @memberof SystemVersionInfo
   */
  system?: SystemInfo;
  /**
   *
   * @type {BuildInfo}
   * @memberof SystemVersionInfo
   */
  build?: BuildInfo;
}
/**
 *
 * @export
 * @interface UploadAttachment200Response
 */
export interface UploadAttachment200Response {
  /**
   *
   * @type {string}
   * @memberof UploadAttachment200Response
   */
  status?: string;
}
/**
 *
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
  /**
   *
   * @type {string}
   * @memberof UserResponse
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof UserResponse
   */
  role: UserResponseRoleEnum;
  /**
   *
   * @type {string}
   * @memberof UserResponse
   */
  createdAt: string;
}

export const UserResponseRoleEnum = {
  ReadOnly: 'read-only',
  ReadWrite: 'read-write',
  Admin: 'admin',
} as const;

export type UserResponseRoleEnum =
  (typeof UserResponseRoleEnum)[keyof typeof UserResponseRoleEnum];

/**
 * DataExportApi - axios parameter creator
 * @export
 */
export const DataExportApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns a ZIP file containing multiple Parquet files, each representing a flattened export of observations per form type. Supports downloading the entire dataset as separate Parquet files bundled together.
     * @summary Download a ZIP archive of Parquet exports
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getParquetExportZip: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/dataexport/parquet`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DataExportApi - functional programming interface
 * @export
 */
export const DataExportApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    DataExportApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns a ZIP file containing multiple Parquet files, each representing a flattened export of observations per form type. Supports downloading the entire dataset as separate Parquet files bundled together.
     * @summary Download a ZIP archive of Parquet exports
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getParquetExportZip(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getParquetExportZip(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DataExportApi.getParquetExportZip']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * DataExportApi - factory interface
 * @export
 */
export const DataExportApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DataExportApiFp(configuration);
  return {
    /**
     * Returns a ZIP file containing multiple Parquet files, each representing a flattened export of observations per form type. Supports downloading the entire dataset as separate Parquet files bundled together.
     * @summary Download a ZIP archive of Parquet exports
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getParquetExportZip(options?: RawAxiosRequestConfig): AxiosPromise<File> {
      return localVarFp
        .getParquetExportZip(options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * DataExportApi - object-oriented interface
 * @export
 * @class DataExportApi
 * @extends {BaseAPI}
 */
export class DataExportApi extends BaseAPI {
  /**
   * Returns a ZIP file containing multiple Parquet files, each representing a flattened export of observations per form type. Supports downloading the entire dataset as separate Parquet files bundled together.
   * @summary Download a ZIP archive of Parquet exports
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataExportApi
   */
  public getParquetExportZip(options?: RawAxiosRequestConfig) {
    return DataExportApiFp(this.configuration)
      .getParquetExportZip(options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Change password for the currently authenticated user
     * @summary Change user password (authenticated user)\'s password
     * @param {ChangePasswordRequest} changePasswordRequest
     * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePassword: async (
      changePasswordRequest: ChangePasswordRequest,
      xApiVersion?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'changePasswordRequest' is not null or undefined
      assertParamExists(
        'changePassword',
        'changePasswordRequest',
        changePasswordRequest,
      );
      const localVarPath = `/users/change-password`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      if (xApiVersion != null) {
        localVarHeaderParameter['x-api-version'] = String(xApiVersion);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        changePasswordRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Check if an attachment exists
     * @param {string} attachmentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkAttachmentExists: async (
      attachmentId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'attachmentId' is not null or undefined
      assertParamExists('checkAttachmentExists', 'attachmentId', attachmentId);
      const localVarPath = `/attachments/{attachment_id}`.replace(
        `{${'attachment_id'}}`,
        encodeURIComponent(String(attachmentId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'HEAD',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new user with specified username, password, and role
     * @summary Create a new user (admin only)
     * @param {CreateUserRequest} createUserRequest
     * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser: async (
      createUserRequest: CreateUserRequest,
      xApiVersion?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createUserRequest' is not null or undefined
      assertParamExists('createUser', 'createUserRequest', createUserRequest);
      const localVarPath = `/users/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      if (xApiVersion != null) {
        localVarHeaderParameter['x-api-version'] = String(xApiVersion);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createUserRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a user by username
     * @summary Delete a user (admin only)
     * @param {string} username Username of the user to delete
     * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser: async (
      username: string,
      xApiVersion?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('deleteUser', 'username', username);
      const localVarPath = `/users/{username}`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (xApiVersion != null) {
        localVarHeaderParameter['x-api-version'] = String(xApiVersion);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Download a specific file from the app bundle
     * @param {string} path
     * @param {boolean} [preview] If true, returns the file from the latest version including unreleased changes
     * @param {string} [ifNoneMatch]
     * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadAppBundleFile: async (
      path: string,
      preview?: boolean,
      ifNoneMatch?: string,
      xApiVersion?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'path' is not null or undefined
      assertParamExists('downloadAppBundleFile', 'path', path);
      const localVarPath = `/app-bundle/download/{path}`.replace(
        `{${'path'}}`,
        encodeURIComponent(String(path)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (preview !== undefined) {
        localVarQueryParameter['preview'] = preview;
      }

      if (ifNoneMatch != null) {
        localVarHeaderParameter['if-none-match'] = String(ifNoneMatch);
      }
      if (xApiVersion != null) {
        localVarHeaderParameter['x-api-version'] = String(xApiVersion);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Download an attachment by ID
     * @param {string} attachmentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadAttachment: async (
      attachmentId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'attachmentId' is not null or undefined
      assertParamExists('downloadAttachment', 'attachmentId', attachmentId);
      const localVarPath = `/attachments/{attachment_id}`.replace(
        `{${'attachment_id'}}`,
        encodeURIComponent(String(attachmentId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Compares two versions of the app bundle and returns detailed changes
     * @summary Get changes between two app bundle versions
     * @param {string} [current] The current version (defaults to latest)
     * @param {string} [target] The target version to compare against (defaults to previous version)
     * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAppBundleChanges: async (
      current?: string,
      target?: string,
      xApiVersion?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/app-bundle/changes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (current !== undefined) {
        localVarQueryParameter['current'] = current;
      }

      if (target !== undefined) {
        localVarQueryParameter['target'] = target;
      }

      if (xApiVersion != null) {
        localVarHeaderParameter['x-api-version'] = String(xApiVersion);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the current custom app bundle manifest
     * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAppBundleManifest: async (
      xApiVersion?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/app-bundle/manifest`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (xApiVersion != null) {
        localVarHeaderParameter['x-api-version'] = String(xApiVersion);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a list of available app bundle versions
     * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAppBundleVersions: async (
      xApiVersion?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/app-bundle/versions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (xApiVersion != null) {
        localVarHeaderParameter['x-api-version'] = String(xApiVersion);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a manifest of attachment changes (new, updated, deleted) since a specified data version
     * @summary Get attachment manifest for incremental sync
     * @param {AttachmentManifestRequest} attachmentManifestRequest
     * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAttachmentManifest: async (
      attachmentManifestRequest: AttachmentManifestRequest,
      xApiVersion?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'attachmentManifestRequest' is not null or undefined
      assertParamExists(
        'getAttachmentManifest',
        'attachmentManifestRequest',
        attachmentManifestRequest,
      );
      const localVarPath = `/attachments/manifest`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      if (xApiVersion != null) {
        localVarHeaderParameter['x-api-version'] = String(xApiVersion);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        attachmentManifestRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns detailed version information about the server, including build information and system details
     * @summary Get server version and system information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVersion: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/version`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve a list of all users in the system. Admin access required.
     * @summary List all users (admin only)
     * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUsers: async (
      xApiVersion?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (xApiVersion != null) {
        localVarHeaderParameter['x-api-version'] = String(xApiVersion);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Obtain a JWT token by providing username and password
     * @summary Authenticate user and return JWT tokens
     * @param {LoginRequest} loginRequest
     * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login: async (
      loginRequest: LoginRequest,
      xApiVersion?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'loginRequest' is not null or undefined
      assertParamExists('login', 'loginRequest', loginRequest);
      const localVarPath = `/auth/login`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      if (xApiVersion != null) {
        localVarHeaderParameter['x-api-version'] = String(xApiVersion);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        loginRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Upload a new app bundle (admin only)
     * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @param {File} [bundle] ZIP file containing the new app bundle
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pushAppBundle: async (
      xApiVersion?: string,
      bundle?: File,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/app-bundle/push`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)();

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (bundle !== undefined) {
        localVarFormParams.append('bundle', bundle as any);
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      if (xApiVersion != null) {
        localVarHeaderParameter['x-api-version'] = String(xApiVersion);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Obtain a new JWT token using a refresh token
     * @summary Refresh JWT token
     * @param {RefreshTokenRequest} refreshTokenRequest
     * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken: async (
      refreshTokenRequest: RefreshTokenRequest,
      xApiVersion?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'refreshTokenRequest' is not null or undefined
      assertParamExists(
        'refreshToken',
        'refreshTokenRequest',
        refreshTokenRequest,
      );
      const localVarPath = `/auth/refresh`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      if (xApiVersion != null) {
        localVarHeaderParameter['x-api-version'] = String(xApiVersion);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        refreshTokenRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Reset password for a specified user
     * @summary Reset user password (admin only)
     * @param {ResetUserPasswordRequest} resetUserPasswordRequest
     * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetUserPassword: async (
      resetUserPasswordRequest: ResetUserPasswordRequest,
      xApiVersion?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'resetUserPasswordRequest' is not null or undefined
      assertParamExists(
        'resetUserPassword',
        'resetUserPasswordRequest',
        resetUserPasswordRequest,
      );
      const localVarPath = `/users/reset-password`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      if (xApiVersion != null) {
        localVarHeaderParameter['x-api-version'] = String(xApiVersion);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resetUserPasswordRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Switch to a specific app bundle version (admin only)
     * @param {string} version Version identifier to switch to
     * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    switchAppBundleVersion: async (
      version: string,
      xApiVersion?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'version' is not null or undefined
      assertParamExists('switchAppBundleVersion', 'version', version);
      const localVarPath = `/app-bundle/switch/{version}`.replace(
        `{${'version'}}`,
        encodeURIComponent(String(version)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (xApiVersion != null) {
        localVarHeaderParameter['x-api-version'] = String(xApiVersion);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves records that have changed since a specified version.  **Pagination Pattern:** 1. Send initial request with `since.version` (or omit for all records) 2. Process returned records 3. If `has_more` is true, make next request using `change_cutoff` as the new `since.version` 4. Repeat until `has_more` is false  Example pagination flow: - Request 1: `since: {version: 100}`  Response: `change_cutoff: 150, has_more: true` - Request 2: `since: {version: 150}`  Response: `change_cutoff: 200, has_more: false`
     * @summary Pull updated records since last sync
     * @param {SyncPullRequest} syncPullRequest
     * @param {string} [schemaType] Filter by schemaType
     * @param {number} [limit] Maximum number of records to return
     * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    syncPull: async (
      syncPullRequest: SyncPullRequest,
      schemaType?: string,
      limit?: number,
      xApiVersion?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'syncPullRequest' is not null or undefined
      assertParamExists('syncPull', 'syncPullRequest', syncPullRequest);
      const localVarPath = `/sync/pull`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (schemaType !== undefined) {
        localVarQueryParameter['schemaType'] = schemaType;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      if (xApiVersion != null) {
        localVarHeaderParameter['x-api-version'] = String(xApiVersion);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        syncPullRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Push new or updated records to the server
     * @param {SyncPushRequest} syncPushRequest
     * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    syncPush: async (
      syncPushRequest: SyncPushRequest,
      xApiVersion?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'syncPushRequest' is not null or undefined
      assertParamExists('syncPush', 'syncPushRequest', syncPushRequest);
      const localVarPath = `/sync/push`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      if (xApiVersion != null) {
        localVarHeaderParameter['x-api-version'] = String(xApiVersion);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        syncPushRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Upload a new attachment with specified ID
     * @param {string} attachmentId
     * @param {File} file The binary file to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadAttachment: async (
      attachmentId: string,
      file: File,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'attachmentId' is not null or undefined
      assertParamExists('uploadAttachment', 'attachmentId', attachmentId);
      // verify required parameter 'file' is not null or undefined
      assertParamExists('uploadAttachment', 'file', file);
      const localVarPath = `/attachments/{attachment_id}`.replace(
        `{${'attachment_id'}}`,
        encodeURIComponent(String(attachmentId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)();

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (file !== undefined) {
        localVarFormParams.append('file', file as any);
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration);
  return {
    /**
     * Change password for the currently authenticated user
     * @summary Change user password (authenticated user)\'s password
     * @param {ChangePasswordRequest} changePasswordRequest
     * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async changePassword(
      changePasswordRequest: ChangePasswordRequest,
      xApiVersion?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ChangePassword200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(
        changePasswordRequest,
        xApiVersion,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.changePassword']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Check if an attachment exists
     * @param {string} attachmentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async checkAttachmentExists(
      attachmentId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.checkAttachmentExists(
          attachmentId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.checkAttachmentExists']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Create a new user with specified username, password, and role
     * @summary Create a new user (admin only)
     * @param {CreateUserRequest} createUserRequest
     * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUser(
      createUserRequest: CreateUserRequest,
      xApiVersion?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(
        createUserRequest,
        xApiVersion,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.createUser']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Delete a user by username
     * @summary Delete a user (admin only)
     * @param {string} username Username of the user to delete
     * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUser(
      username: string,
      xApiVersion?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<DeleteUser200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(
        username,
        xApiVersion,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.deleteUser']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Download a specific file from the app bundle
     * @param {string} path
     * @param {boolean} [preview] If true, returns the file from the latest version including unreleased changes
     * @param {string} [ifNoneMatch]
     * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async downloadAppBundleFile(
      path: string,
      preview?: boolean,
      ifNoneMatch?: string,
      xApiVersion?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.downloadAppBundleFile(
          path,
          preview,
          ifNoneMatch,
          xApiVersion,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.downloadAppBundleFile']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Download an attachment by ID
     * @param {string} attachmentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async downloadAttachment(
      attachmentId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.downloadAttachment(
          attachmentId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.downloadAttachment']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Compares two versions of the app bundle and returns detailed changes
     * @summary Get changes between two app bundle versions
     * @param {string} [current] The current version (defaults to latest)
     * @param {string} [target] The target version to compare against (defaults to previous version)
     * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAppBundleChanges(
      current?: string,
      target?: string,
      xApiVersion?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChangeLog>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAppBundleChanges(
          current,
          target,
          xApiVersion,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getAppBundleChanges']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get the current custom app bundle manifest
     * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAppBundleManifest(
      xApiVersion?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<AppBundleManifest>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAppBundleManifest(
          xApiVersion,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getAppBundleManifest']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get a list of available app bundle versions
     * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAppBundleVersions(
      xApiVersion?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<AppBundleVersions>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAppBundleVersions(
          xApiVersion,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getAppBundleVersions']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns a manifest of attachment changes (new, updated, deleted) since a specified data version
     * @summary Get attachment manifest for incremental sync
     * @param {AttachmentManifestRequest} attachmentManifestRequest
     * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAttachmentManifest(
      attachmentManifestRequest: AttachmentManifestRequest,
      xApiVersion?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<AttachmentManifestResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAttachmentManifest(
          attachmentManifestRequest,
          xApiVersion,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getAttachmentManifest']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns detailed version information about the server, including build information and system details
     * @summary Get server version and system information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVersion(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SystemVersionInfo>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getVersion(
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getVersion']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieve a list of all users in the system. Admin access required.
     * @summary List all users (admin only)
     * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listUsers(
      xApiVersion?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<UserResponse>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(
        xApiVersion,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.listUsers']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Obtain a JWT token by providing username and password
     * @summary Authenticate user and return JWT tokens
     * @param {LoginRequest} loginRequest
     * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async login(
      loginRequest: LoginRequest,
      xApiVersion?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.login(
        loginRequest,
        xApiVersion,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.login']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Upload a new app bundle (admin only)
     * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @param {File} [bundle] ZIP file containing the new app bundle
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pushAppBundle(
      xApiVersion?: string,
      bundle?: File,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<AppBundlePushResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.pushAppBundle(
        xApiVersion,
        bundle,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.pushAppBundle']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Obtain a new JWT token using a refresh token
     * @summary Refresh JWT token
     * @param {RefreshTokenRequest} refreshTokenRequest
     * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refreshToken(
      refreshTokenRequest: RefreshTokenRequest,
      xApiVersion?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(
        refreshTokenRequest,
        xApiVersion,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.refreshToken']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Reset password for a specified user
     * @summary Reset user password (admin only)
     * @param {ResetUserPasswordRequest} resetUserPasswordRequest
     * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resetUserPassword(
      resetUserPasswordRequest: ResetUserPasswordRequest,
      xApiVersion?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ResetUserPassword200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.resetUserPassword(
          resetUserPasswordRequest,
          xApiVersion,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.resetUserPassword']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Switch to a specific app bundle version (admin only)
     * @param {string} version Version identifier to switch to
     * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async switchAppBundleVersion(
      version: string,
      xApiVersion?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SwitchAppBundleVersion200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.switchAppBundleVersion(
          version,
          xApiVersion,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.switchAppBundleVersion']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieves records that have changed since a specified version.  **Pagination Pattern:** 1. Send initial request with `since.version` (or omit for all records) 2. Process returned records 3. If `has_more` is true, make next request using `change_cutoff` as the new `since.version` 4. Repeat until `has_more` is false  Example pagination flow: - Request 1: `since: {version: 100}`  Response: `change_cutoff: 150, has_more: true` - Request 2: `since: {version: 150}`  Response: `change_cutoff: 200, has_more: false`
     * @summary Pull updated records since last sync
     * @param {SyncPullRequest} syncPullRequest
     * @param {string} [schemaType] Filter by schemaType
     * @param {number} [limit] Maximum number of records to return
     * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async syncPull(
      syncPullRequest: SyncPullRequest,
      schemaType?: string,
      limit?: number,
      xApiVersion?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SyncPullResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.syncPull(
        syncPullRequest,
        schemaType,
        limit,
        xApiVersion,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.syncPull']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Push new or updated records to the server
     * @param {SyncPushRequest} syncPushRequest
     * @param {string} [xApiVersion] Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async syncPush(
      syncPushRequest: SyncPushRequest,
      xApiVersion?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SyncPushResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.syncPush(
        syncPushRequest,
        xApiVersion,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.syncPush']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Upload a new attachment with specified ID
     * @param {string} attachmentId
     * @param {File} file The binary file to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadAttachment(
      attachmentId: string,
      file: File,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UploadAttachment200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.uploadAttachment(
          attachmentId,
          file,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.uploadAttachment']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DefaultApiFp(configuration);
  return {
    /**
     * Change password for the currently authenticated user
     * @summary Change user password (authenticated user)\'s password
     * @param {DefaultApiChangePasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePassword(
      requestParameters: DefaultApiChangePasswordRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ChangePassword200Response> {
      return localVarFp
        .changePassword(
          requestParameters.changePasswordRequest,
          requestParameters.xApiVersion,
          options,
        )
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Check if an attachment exists
     * @param {DefaultApiCheckAttachmentExistsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkAttachmentExists(
      requestParameters: DefaultApiCheckAttachmentExistsRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .checkAttachmentExists(requestParameters.attachmentId, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Create a new user with specified username, password, and role
     * @summary Create a new user (admin only)
     * @param {DefaultApiCreateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(
      requestParameters: DefaultApiCreateUserRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UserResponse> {
      return localVarFp
        .createUser(
          requestParameters.createUserRequest,
          requestParameters.xApiVersion,
          options,
        )
        .then(request => request(axios, basePath));
    },
    /**
     * Delete a user by username
     * @summary Delete a user (admin only)
     * @param {DefaultApiDeleteUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(
      requestParameters: DefaultApiDeleteUserRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<DeleteUser200Response> {
      return localVarFp
        .deleteUser(
          requestParameters.username,
          requestParameters.xApiVersion,
          options,
        )
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Download a specific file from the app bundle
     * @param {DefaultApiDownloadAppBundleFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadAppBundleFile(
      requestParameters: DefaultApiDownloadAppBundleFileRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<File> {
      return localVarFp
        .downloadAppBundleFile(
          requestParameters.path,
          requestParameters.preview,
          requestParameters.ifNoneMatch,
          requestParameters.xApiVersion,
          options,
        )
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Download an attachment by ID
     * @param {DefaultApiDownloadAttachmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadAttachment(
      requestParameters: DefaultApiDownloadAttachmentRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<File> {
      return localVarFp
        .downloadAttachment(requestParameters.attachmentId, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Compares two versions of the app bundle and returns detailed changes
     * @summary Get changes between two app bundle versions
     * @param {DefaultApiGetAppBundleChangesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAppBundleChanges(
      requestParameters: DefaultApiGetAppBundleChangesRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ChangeLog> {
      return localVarFp
        .getAppBundleChanges(
          requestParameters.current,
          requestParameters.target,
          requestParameters.xApiVersion,
          options,
        )
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get the current custom app bundle manifest
     * @param {DefaultApiGetAppBundleManifestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAppBundleManifest(
      requestParameters: DefaultApiGetAppBundleManifestRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<AppBundleManifest> {
      return localVarFp
        .getAppBundleManifest(requestParameters.xApiVersion, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get a list of available app bundle versions
     * @param {DefaultApiGetAppBundleVersionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAppBundleVersions(
      requestParameters: DefaultApiGetAppBundleVersionsRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<AppBundleVersions> {
      return localVarFp
        .getAppBundleVersions(requestParameters.xApiVersion, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Returns a manifest of attachment changes (new, updated, deleted) since a specified data version
     * @summary Get attachment manifest for incremental sync
     * @param {DefaultApiGetAttachmentManifestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAttachmentManifest(
      requestParameters: DefaultApiGetAttachmentManifestRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<AttachmentManifestResponse> {
      return localVarFp
        .getAttachmentManifest(
          requestParameters.attachmentManifestRequest,
          requestParameters.xApiVersion,
          options,
        )
        .then(request => request(axios, basePath));
    },
    /**
     * Returns detailed version information about the server, including build information and system details
     * @summary Get server version and system information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVersion(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SystemVersionInfo> {
      return localVarFp
        .getVersion(options)
        .then(request => request(axios, basePath));
    },
    /**
     * Retrieve a list of all users in the system. Admin access required.
     * @summary List all users (admin only)
     * @param {DefaultApiListUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUsers(
      requestParameters: DefaultApiListUsersRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<UserResponse>> {
      return localVarFp
        .listUsers(requestParameters.xApiVersion, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Obtain a JWT token by providing username and password
     * @summary Authenticate user and return JWT tokens
     * @param {DefaultApiLoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login(
      requestParameters: DefaultApiLoginRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<AuthResponse> {
      return localVarFp
        .login(
          requestParameters.loginRequest,
          requestParameters.xApiVersion,
          options,
        )
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Upload a new app bundle (admin only)
     * @param {DefaultApiPushAppBundleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pushAppBundle(
      requestParameters: DefaultApiPushAppBundleRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<AppBundlePushResponse> {
      return localVarFp
        .pushAppBundle(
          requestParameters.xApiVersion,
          requestParameters.bundle,
          options,
        )
        .then(request => request(axios, basePath));
    },
    /**
     * Obtain a new JWT token using a refresh token
     * @summary Refresh JWT token
     * @param {DefaultApiRefreshTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken(
      requestParameters: DefaultApiRefreshTokenRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<AuthResponse> {
      return localVarFp
        .refreshToken(
          requestParameters.refreshTokenRequest,
          requestParameters.xApiVersion,
          options,
        )
        .then(request => request(axios, basePath));
    },
    /**
     * Reset password for a specified user
     * @summary Reset user password (admin only)
     * @param {DefaultApiResetUserPasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetUserPassword(
      requestParameters: DefaultApiResetUserPasswordRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResetUserPassword200Response> {
      return localVarFp
        .resetUserPassword(
          requestParameters.resetUserPasswordRequest,
          requestParameters.xApiVersion,
          options,
        )
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Switch to a specific app bundle version (admin only)
     * @param {DefaultApiSwitchAppBundleVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    switchAppBundleVersion(
      requestParameters: DefaultApiSwitchAppBundleVersionRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SwitchAppBundleVersion200Response> {
      return localVarFp
        .switchAppBundleVersion(
          requestParameters.version,
          requestParameters.xApiVersion,
          options,
        )
        .then(request => request(axios, basePath));
    },
    /**
     * Retrieves records that have changed since a specified version.  **Pagination Pattern:** 1. Send initial request with `since.version` (or omit for all records) 2. Process returned records 3. If `has_more` is true, make next request using `change_cutoff` as the new `since.version` 4. Repeat until `has_more` is false  Example pagination flow: - Request 1: `since: {version: 100}`  Response: `change_cutoff: 150, has_more: true` - Request 2: `since: {version: 150}`  Response: `change_cutoff: 200, has_more: false`
     * @summary Pull updated records since last sync
     * @param {DefaultApiSyncPullRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    syncPull(
      requestParameters: DefaultApiSyncPullRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SyncPullResponse> {
      return localVarFp
        .syncPull(
          requestParameters.syncPullRequest,
          requestParameters.schemaType,
          requestParameters.limit,
          requestParameters.xApiVersion,
          options,
        )
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Push new or updated records to the server
     * @param {DefaultApiSyncPushRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    syncPush(
      requestParameters: DefaultApiSyncPushRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SyncPushResponse> {
      return localVarFp
        .syncPush(
          requestParameters.syncPushRequest,
          requestParameters.xApiVersion,
          options,
        )
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Upload a new attachment with specified ID
     * @param {DefaultApiUploadAttachmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadAttachment(
      requestParameters: DefaultApiUploadAttachmentRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UploadAttachment200Response> {
      return localVarFp
        .uploadAttachment(
          requestParameters.attachmentId,
          requestParameters.file,
          options,
        )
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for changePassword operation in DefaultApi.
 * @export
 * @interface DefaultApiChangePasswordRequest
 */
export interface DefaultApiChangePasswordRequest {
  /**
   *
   * @type {ChangePasswordRequest}
   * @memberof DefaultApiChangePassword
   */
  readonly changePasswordRequest: ChangePasswordRequest;

  /**
   * Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
   * @type {string}
   * @memberof DefaultApiChangePassword
   */
  readonly xApiVersion?: string;
}

/**
 * Request parameters for checkAttachmentExists operation in DefaultApi.
 * @export
 * @interface DefaultApiCheckAttachmentExistsRequest
 */
export interface DefaultApiCheckAttachmentExistsRequest {
  /**
   *
   * @type {string}
   * @memberof DefaultApiCheckAttachmentExists
   */
  readonly attachmentId: string;
}

/**
 * Request parameters for createUser operation in DefaultApi.
 * @export
 * @interface DefaultApiCreateUserRequest
 */
export interface DefaultApiCreateUserRequest {
  /**
   *
   * @type {CreateUserRequest}
   * @memberof DefaultApiCreateUser
   */
  readonly createUserRequest: CreateUserRequest;

  /**
   * Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
   * @type {string}
   * @memberof DefaultApiCreateUser
   */
  readonly xApiVersion?: string;
}

/**
 * Request parameters for deleteUser operation in DefaultApi.
 * @export
 * @interface DefaultApiDeleteUserRequest
 */
export interface DefaultApiDeleteUserRequest {
  /**
   * Username of the user to delete
   * @type {string}
   * @memberof DefaultApiDeleteUser
   */
  readonly username: string;

  /**
   * Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
   * @type {string}
   * @memberof DefaultApiDeleteUser
   */
  readonly xApiVersion?: string;
}

/**
 * Request parameters for downloadAppBundleFile operation in DefaultApi.
 * @export
 * @interface DefaultApiDownloadAppBundleFileRequest
 */
export interface DefaultApiDownloadAppBundleFileRequest {
  /**
   *
   * @type {string}
   * @memberof DefaultApiDownloadAppBundleFile
   */
  readonly path: string;

  /**
   * If true, returns the file from the latest version including unreleased changes
   * @type {boolean}
   * @memberof DefaultApiDownloadAppBundleFile
   */
  readonly preview?: boolean;

  /**
   *
   * @type {string}
   * @memberof DefaultApiDownloadAppBundleFile
   */
  readonly ifNoneMatch?: string;

  /**
   * Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
   * @type {string}
   * @memberof DefaultApiDownloadAppBundleFile
   */
  readonly xApiVersion?: string;
}

/**
 * Request parameters for downloadAttachment operation in DefaultApi.
 * @export
 * @interface DefaultApiDownloadAttachmentRequest
 */
export interface DefaultApiDownloadAttachmentRequest {
  /**
   *
   * @type {string}
   * @memberof DefaultApiDownloadAttachment
   */
  readonly attachmentId: string;
}

/**
 * Request parameters for getAppBundleChanges operation in DefaultApi.
 * @export
 * @interface DefaultApiGetAppBundleChangesRequest
 */
export interface DefaultApiGetAppBundleChangesRequest {
  /**
   * The current version (defaults to latest)
   * @type {string}
   * @memberof DefaultApiGetAppBundleChanges
   */
  readonly current?: string;

  /**
   * The target version to compare against (defaults to previous version)
   * @type {string}
   * @memberof DefaultApiGetAppBundleChanges
   */
  readonly target?: string;

  /**
   * Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
   * @type {string}
   * @memberof DefaultApiGetAppBundleChanges
   */
  readonly xApiVersion?: string;
}

/**
 * Request parameters for getAppBundleManifest operation in DefaultApi.
 * @export
 * @interface DefaultApiGetAppBundleManifestRequest
 */
export interface DefaultApiGetAppBundleManifestRequest {
  /**
   * Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
   * @type {string}
   * @memberof DefaultApiGetAppBundleManifest
   */
  readonly xApiVersion?: string;
}

/**
 * Request parameters for getAppBundleVersions operation in DefaultApi.
 * @export
 * @interface DefaultApiGetAppBundleVersionsRequest
 */
export interface DefaultApiGetAppBundleVersionsRequest {
  /**
   * Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
   * @type {string}
   * @memberof DefaultApiGetAppBundleVersions
   */
  readonly xApiVersion?: string;
}

/**
 * Request parameters for getAttachmentManifest operation in DefaultApi.
 * @export
 * @interface DefaultApiGetAttachmentManifestRequest
 */
export interface DefaultApiGetAttachmentManifestRequest {
  /**
   *
   * @type {AttachmentManifestRequest}
   * @memberof DefaultApiGetAttachmentManifest
   */
  readonly attachmentManifestRequest: AttachmentManifestRequest;

  /**
   * Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
   * @type {string}
   * @memberof DefaultApiGetAttachmentManifest
   */
  readonly xApiVersion?: string;
}

/**
 * Request parameters for listUsers operation in DefaultApi.
 * @export
 * @interface DefaultApiListUsersRequest
 */
export interface DefaultApiListUsersRequest {
  /**
   * Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
   * @type {string}
   * @memberof DefaultApiListUsers
   */
  readonly xApiVersion?: string;
}

/**
 * Request parameters for login operation in DefaultApi.
 * @export
 * @interface DefaultApiLoginRequest
 */
export interface DefaultApiLoginRequest {
  /**
   *
   * @type {LoginRequest}
   * @memberof DefaultApiLogin
   */
  readonly loginRequest: LoginRequest;

  /**
   * Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
   * @type {string}
   * @memberof DefaultApiLogin
   */
  readonly xApiVersion?: string;
}

/**
 * Request parameters for pushAppBundle operation in DefaultApi.
 * @export
 * @interface DefaultApiPushAppBundleRequest
 */
export interface DefaultApiPushAppBundleRequest {
  /**
   * Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
   * @type {string}
   * @memberof DefaultApiPushAppBundle
   */
  readonly xApiVersion?: string;

  /**
   * ZIP file containing the new app bundle
   * @type {File}
   * @memberof DefaultApiPushAppBundle
   */
  readonly bundle?: File;
}

/**
 * Request parameters for refreshToken operation in DefaultApi.
 * @export
 * @interface DefaultApiRefreshTokenRequest
 */
export interface DefaultApiRefreshTokenRequest {
  /**
   *
   * @type {RefreshTokenRequest}
   * @memberof DefaultApiRefreshToken
   */
  readonly refreshTokenRequest: RefreshTokenRequest;

  /**
   * Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
   * @type {string}
   * @memberof DefaultApiRefreshToken
   */
  readonly xApiVersion?: string;
}

/**
 * Request parameters for resetUserPassword operation in DefaultApi.
 * @export
 * @interface DefaultApiResetUserPasswordRequest
 */
export interface DefaultApiResetUserPasswordRequest {
  /**
   *
   * @type {ResetUserPasswordRequest}
   * @memberof DefaultApiResetUserPassword
   */
  readonly resetUserPasswordRequest: ResetUserPasswordRequest;

  /**
   * Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
   * @type {string}
   * @memberof DefaultApiResetUserPassword
   */
  readonly xApiVersion?: string;
}

/**
 * Request parameters for switchAppBundleVersion operation in DefaultApi.
 * @export
 * @interface DefaultApiSwitchAppBundleVersionRequest
 */
export interface DefaultApiSwitchAppBundleVersionRequest {
  /**
   * Version identifier to switch to
   * @type {string}
   * @memberof DefaultApiSwitchAppBundleVersion
   */
  readonly version: string;

  /**
   * Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
   * @type {string}
   * @memberof DefaultApiSwitchAppBundleVersion
   */
  readonly xApiVersion?: string;
}

/**
 * Request parameters for syncPull operation in DefaultApi.
 * @export
 * @interface DefaultApiSyncPullRequest
 */
export interface DefaultApiSyncPullRequest {
  /**
   *
   * @type {SyncPullRequest}
   * @memberof DefaultApiSyncPull
   */
  readonly syncPullRequest: SyncPullRequest;

  /**
   * Filter by schemaType
   * @type {string}
   * @memberof DefaultApiSyncPull
   */
  readonly schemaType?: string;

  /**
   * Maximum number of records to return
   * @type {number}
   * @memberof DefaultApiSyncPull
   */
  readonly limit?: number;

  /**
   * Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
   * @type {string}
   * @memberof DefaultApiSyncPull
   */
  readonly xApiVersion?: string;
}

/**
 * Request parameters for syncPush operation in DefaultApi.
 * @export
 * @interface DefaultApiSyncPushRequest
 */
export interface DefaultApiSyncPushRequest {
  /**
   *
   * @type {SyncPushRequest}
   * @memberof DefaultApiSyncPush
   */
  readonly syncPushRequest: SyncPushRequest;

  /**
   * Optional API version header using semantic versioning (MAJOR.MINOR.PATCH)
   * @type {string}
   * @memberof DefaultApiSyncPush
   */
  readonly xApiVersion?: string;
}

/**
 * Request parameters for uploadAttachment operation in DefaultApi.
 * @export
 * @interface DefaultApiUploadAttachmentRequest
 */
export interface DefaultApiUploadAttachmentRequest {
  /**
   *
   * @type {string}
   * @memberof DefaultApiUploadAttachment
   */
  readonly attachmentId: string;

  /**
   * The binary file to upload
   * @type {File}
   * @memberof DefaultApiUploadAttachment
   */
  readonly file: File;
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   * Change password for the currently authenticated user
   * @summary Change user password (authenticated user)\'s password
   * @param {DefaultApiChangePasswordRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public changePassword(
    requestParameters: DefaultApiChangePasswordRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .changePassword(
        requestParameters.changePasswordRequest,
        requestParameters.xApiVersion,
        options,
      )
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Check if an attachment exists
   * @param {DefaultApiCheckAttachmentExistsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public checkAttachmentExists(
    requestParameters: DefaultApiCheckAttachmentExistsRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .checkAttachmentExists(requestParameters.attachmentId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Create a new user with specified username, password, and role
   * @summary Create a new user (admin only)
   * @param {DefaultApiCreateUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createUser(
    requestParameters: DefaultApiCreateUserRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .createUser(
        requestParameters.createUserRequest,
        requestParameters.xApiVersion,
        options,
      )
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Delete a user by username
   * @summary Delete a user (admin only)
   * @param {DefaultApiDeleteUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteUser(
    requestParameters: DefaultApiDeleteUserRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .deleteUser(
        requestParameters.username,
        requestParameters.xApiVersion,
        options,
      )
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Download a specific file from the app bundle
   * @param {DefaultApiDownloadAppBundleFileRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public downloadAppBundleFile(
    requestParameters: DefaultApiDownloadAppBundleFileRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .downloadAppBundleFile(
        requestParameters.path,
        requestParameters.preview,
        requestParameters.ifNoneMatch,
        requestParameters.xApiVersion,
        options,
      )
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Download an attachment by ID
   * @param {DefaultApiDownloadAttachmentRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public downloadAttachment(
    requestParameters: DefaultApiDownloadAttachmentRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .downloadAttachment(requestParameters.attachmentId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Compares two versions of the app bundle and returns detailed changes
   * @summary Get changes between two app bundle versions
   * @param {DefaultApiGetAppBundleChangesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getAppBundleChanges(
    requestParameters: DefaultApiGetAppBundleChangesRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .getAppBundleChanges(
        requestParameters.current,
        requestParameters.target,
        requestParameters.xApiVersion,
        options,
      )
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the current custom app bundle manifest
   * @param {DefaultApiGetAppBundleManifestRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getAppBundleManifest(
    requestParameters: DefaultApiGetAppBundleManifestRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .getAppBundleManifest(requestParameters.xApiVersion, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a list of available app bundle versions
   * @param {DefaultApiGetAppBundleVersionsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getAppBundleVersions(
    requestParameters: DefaultApiGetAppBundleVersionsRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .getAppBundleVersions(requestParameters.xApiVersion, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Returns a manifest of attachment changes (new, updated, deleted) since a specified data version
   * @summary Get attachment manifest for incremental sync
   * @param {DefaultApiGetAttachmentManifestRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getAttachmentManifest(
    requestParameters: DefaultApiGetAttachmentManifestRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .getAttachmentManifest(
        requestParameters.attachmentManifestRequest,
        requestParameters.xApiVersion,
        options,
      )
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Returns detailed version information about the server, including build information and system details
   * @summary Get server version and system information
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getVersion(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getVersion(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Retrieve a list of all users in the system. Admin access required.
   * @summary List all users (admin only)
   * @param {DefaultApiListUsersRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listUsers(
    requestParameters: DefaultApiListUsersRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .listUsers(requestParameters.xApiVersion, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Obtain a JWT token by providing username and password
   * @summary Authenticate user and return JWT tokens
   * @param {DefaultApiLoginRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public login(
    requestParameters: DefaultApiLoginRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .login(
        requestParameters.loginRequest,
        requestParameters.xApiVersion,
        options,
      )
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Upload a new app bundle (admin only)
   * @param {DefaultApiPushAppBundleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public pushAppBundle(
    requestParameters: DefaultApiPushAppBundleRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .pushAppBundle(
        requestParameters.xApiVersion,
        requestParameters.bundle,
        options,
      )
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Obtain a new JWT token using a refresh token
   * @summary Refresh JWT token
   * @param {DefaultApiRefreshTokenRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public refreshToken(
    requestParameters: DefaultApiRefreshTokenRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .refreshToken(
        requestParameters.refreshTokenRequest,
        requestParameters.xApiVersion,
        options,
      )
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Reset password for a specified user
   * @summary Reset user password (admin only)
   * @param {DefaultApiResetUserPasswordRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public resetUserPassword(
    requestParameters: DefaultApiResetUserPasswordRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .resetUserPassword(
        requestParameters.resetUserPasswordRequest,
        requestParameters.xApiVersion,
        options,
      )
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Switch to a specific app bundle version (admin only)
   * @param {DefaultApiSwitchAppBundleVersionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public switchAppBundleVersion(
    requestParameters: DefaultApiSwitchAppBundleVersionRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .switchAppBundleVersion(
        requestParameters.version,
        requestParameters.xApiVersion,
        options,
      )
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Retrieves records that have changed since a specified version.  **Pagination Pattern:** 1. Send initial request with `since.version` (or omit for all records) 2. Process returned records 3. If `has_more` is true, make next request using `change_cutoff` as the new `since.version` 4. Repeat until `has_more` is false  Example pagination flow: - Request 1: `since: {version: 100}`  Response: `change_cutoff: 150, has_more: true` - Request 2: `since: {version: 150}`  Response: `change_cutoff: 200, has_more: false`
   * @summary Pull updated records since last sync
   * @param {DefaultApiSyncPullRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public syncPull(
    requestParameters: DefaultApiSyncPullRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .syncPull(
        requestParameters.syncPullRequest,
        requestParameters.schemaType,
        requestParameters.limit,
        requestParameters.xApiVersion,
        options,
      )
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Push new or updated records to the server
   * @param {DefaultApiSyncPushRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public syncPush(
    requestParameters: DefaultApiSyncPushRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .syncPush(
        requestParameters.syncPushRequest,
        requestParameters.xApiVersion,
        options,
      )
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Upload a new attachment with specified ID
   * @param {DefaultApiUploadAttachmentRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public uploadAttachment(
    requestParameters: DefaultApiUploadAttachmentRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .uploadAttachment(
        requestParameters.attachmentId,
        requestParameters.file,
        options,
      )
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns the current health status of the service
     * @summary Health check endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHealth: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/health`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns the current health status of the service
     * @summary Health check endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getHealth(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GetHealth200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getHealth(
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['HealthApi.getHealth']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = HealthApiFp(configuration);
  return {
    /**
     * Returns the current health status of the service
     * @summary Health check endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHealth(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GetHealth200Response> {
      return localVarFp
        .getHealth(options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
  /**
   * Returns the current health status of the service
   * @summary Health check endpoint
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthApi
   */
  public getHealth(options?: RawAxiosRequestConfig) {
    return HealthApiFp(this.configuration)
      .getHealth(options)
      .then(request => request(this.axios, this.basePath));
  }
}
